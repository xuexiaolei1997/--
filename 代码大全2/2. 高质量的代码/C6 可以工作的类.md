# 可以工作的类

类时一组数据和子程序的集合，这些数据和子程序共享一组内聚的、良好的职责。类也可以是一组子程序的集合，这些子程序提供一组内聚的服务，即使其中并未涉及共用的数据。

## 6.1 类的基础：抽象数据类型（ADT）

### ADT的好处：

可以隐藏实现细节

修改不会影响整个程序

可让接口提供更多信息

更容易提高性能

更容易确定程序的正确性

程序可读性更佳

不必在程序中到处传递数据

可以直接操作现实世界的尸体，不必操作低级的实现结构

### 指导原则

将典型的低级数据类型作为ADT来构建或使用，而不是作为低级数据结构

将文件等通用对象视为ADT

自己可用类似的方式为ADT分级

简单的东西也能当作ADT

直接引用ADT而不必关心它的存储介质

## 6.2 良好的类接口

### **良好的抽象**

在类的接口中呈现一直的抽象级别

一定要理解类实现的是什么抽象

成对提供服务并包含反向操作

将不想管的信息移到另一个类中

尽可能使接口可编程而不是表达语义

小心接口的抽象在修改过程中被侵蚀

不要添加与接口抽象不一致的公共成员

把抽象和内聚放在一起考虑

### 良好的封装

最小化类和成员的可访问性

不能公开成员数据

避免将私有实现细节放到类的接口中

不要对类的用户做出预设

避免友元类

不要因为子程序只使用了公共子程序就把它放到公共接口中

倾向于读代码方便而不是写代码方便

格外警惕在语义上破坏封装

警惕过于紧密的耦合

耦合与抽象/封装相辅相成

## 6.3 设计和实现问题

良好的类接口对创建高质量的程序有很大的帮助。类内部的设计和实现也很重要。

通过包含实现“has a”关系

除非万不得已，否则不要通过私有继承实现has a关系

警告数据成员超过7个的类

### 继承

决定使用继承时，必须做出下面几个决定：

· 每个成员子程序是否对派生类可见？是否有默认实现？默认实现是否可被覆盖（override或称”重写“）？

· 每个数据成员是否对派生类可见？

做出这些决定需要考虑的事情：

通过public继承实现”is a“关系

要么设计继承并提供文档说明，要么禁止继承

遵循里氏替换原则

确保只继承想要继承的东西

| 继承而来的子程序的各种变化 | 可覆盖的             | 不可覆盖的                                               |
| -------------------------- | -------------------- | -------------------------------------------------------- |
| 提供默认实现               | 可覆盖的子程序       | 不可覆盖的自陈虚谷                                       |
| 未提供默认实现             | 抽象且可覆盖的子程序 | 不会用到（一个未经定义但又不让覆盖的子程序时没有意义的） |

不要”覆盖“不可覆盖的成员函数

将通用接口、数据和行为移到继承树中尽可能高的位置

对仅一个实例的类持怀疑态度

对仅一个派生类的基类持怀疑态度

对覆盖了子程序但在子程序的派生版本中什么都不做的类持怀疑态度

避免过深的继承树

尽量利用多态而不是全面的类型检查

让所有数据private而不是protected

### 多重继承

### 成员函数和数据

尽量减少类中的子程序数量

禁止隐式生成不需要的成员函数和操作符

尽量减少类调用的不同子程序的数量

尽量减少对其他类的间接子程序调用

通常情况下，要尽量减少一个类与其他类的协作程度

### 构造函数

尽可能在所有构造函数中初始化所有成员数据

使用private构造函数强制单例属性

除非论证可行，否则使用深拷贝而不是浅拷贝

## 6.4 创建类的理由

建模现实世界中的对象

建模抽象对象

降低复杂性

隔离复杂性

隐藏实现细节

限制变化造成的影响

隐藏全局数据

简化参数传递

建立中心控制点

使代码更容易重用

为程序家族做计划

打包相关操作

实现特定的重构

避免创建万能类

消除无关紧要的类

避免以动词命名的类

## 6.5 语言特定问题

## 6.6 超越类：包

---

> 检查清单：类的质量
>
> | 项                   | 具体内容                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
> | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | 抽象数据类型         | 是否将程序中的类视为抽象数据类型？是否从这个角度评估了它们的接口？                                                                                                                                                                                                                                                                                                                                                                                         |
> | 抽象                 | 类是否有一个中心目的？<br />类的命名是否恰当？其名字表达了其中心目的？<br />类的接口是否呈现了一致的抽象？<br />类的接口是否让人一眼就知道应该如何使用这个类？<br />类的接口是否足够抽象，使开发者无需考虑它的服务具体是如何实现的？能将类看成一个黑盒吗？<br />类的服务是否完整，使其他类无需摆弄其内部数据？<br />是否已经从类中移除了无关信息？<br />是否考虑过把类进一步分解为组件类？是否已经尽可能地分解了？<br />修改类时是否保持了其接口的完整性？ |
> | 封装                 | 是否最小化了类成员的可访问性？<br />类是否避免了公开其成员数据？<br />在编程语言允许的范围内，类是否尽可能对其他类隐藏了其内部实现细节？<br />类的设计是否避免了对其用户做出预设？<br />类是否不依赖于其他类？是松耦合的吗？                                                                                                                                                                                                                               |
> | 继承                 | 继承是否只用来建立”is a“关系？换言之，派生类是否遵循了里氏替换原则？<br />类的文档是否描述了其继承策略？<br />派生类是否避免了”覆盖“不可覆盖的方法？<br />是否将通用接口、数据和行为都放在继承树尽可能高的地方了？<br />继承树很浅吗？<br />基类中的所有数据成员都被定义为private而非protected？                                                                                                                                                       |
> | 与实现相关的其他问题 | 类的数据成员是否只有7个或更少？<br />是否将类中直接和间接调用其他的类的子程序的数量减少到最少了？<br />类是否旨在绝对必要时才与其他类协作？<br />是否所有数据成员都在构造函数中初始化了？<br />是否除非经过论证，否则类都被设计成深拷贝而不是浅拷贝来使用？                                                                                                                                                                                                |
> | 语言特定问题         | 针对你所用的编程语言，是否研究过语言特有的和类相关的问题？                                                                                                                                                                                                                                                                                                                                                                                                 |
