# 高质量的子程序

## 7.1 创建子程序的正当理由

降低复杂性

避免重复代码

支持子类化

隐藏处理顺序

隐藏指针操作

提高可移植性

简化复杂的布尔表达式

提高性能

### 过于简单而无需放到子程序中的操作

## 7.2 子程序级别的设计

考虑内聚性，这样的设计回报是更高的软件可靠性

关于内聚性，通常分几个层次进行讨论

· 功能内聚性。最强的、最好的内聚类型，发生在一个子程序执行一个且只执行一个操作的时候。

· 顺序内聚性。

· 通信内聚性。当一个子程序中有多项操作都使用了相同的数据但彼此没有任何其他关联时，就会存在通信内聚性。

· 瞬时内聚性。如startup。

· 过程内聚性。

· 逻辑内聚性。

· 偶发内聚性。很难将偶发内聚性转换为更好的内聚性，通常需要进行更深入的重新设计和重新实现。

## 7.3 好的子程序名称

描述子程序所作的一切事情

避免使用无意义、模糊或空泛的动词

不要只用数字来区分子程序名称

根据需要为子程序名称选取合适的长度

命名函数时，请使用对其返回值的描述

命名过程时，请使用强势动词后接一个对象宾语

准确使用反义词

为常用操作建立命名规范

## 7.4 一个子程序应该有多长

## 7.5 如何使用子程序参数

按”输入-修改-输出“的顺序来排列参数

可以考虑创建自己专属的IN关键字和OUT关键字

将状态或错误变量放在最后

不要把子程序参数作为工作变量使用

将输入值赋给一个工作变量可以强调该值的来源

对有关参数的接口假设进行文档化说明

将子程序的参数限制在7个左右

考虑为参数的输入、修改和输出使用命名规范

传递维护子程序接口抽象所需的变量或对象

使用有具化名称的参数

确保实参与形参匹配

常见的错误是在子程序调用中放入错误类型的变量

## 7.6 函数使用中的特别注意事项

### 何时使用函数，何时使用过程

如果子程序的主要目的是返回由函数名指示的返回值，那么就使用函数。否则使用过程。

### 设置函数的返回值

注意：检查所有可能的返回逻辑路径。不要返回指向局部数据的引用或指针。

## 7.7 宏子程序和内联子程序

请把宏表达式放置于圆括号之内

把包含多条语句的宏放置于花括号内

### 宏子程序在使用上的限制

### 内联子程序

C++支持inline关键字

请少用内联子程序

> 检查清单：高质量的子程序
>
> | 项           | 具体内容                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
> | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | 主体问题     | 是否有创建该子程序的充足理由？<br />在该子程序中，哪些更适合抽出来放入单独子程序的部分是否都已经放入了单独的子程序中？<br />关于该子程序的命名，是否使用了一个清晰的强势动词加对象的动宾结构来作为一个过程的名称，或者使用了对返回值的描述来作为一个函数的名称？<br />该子程序的名称是否准确地描述了子程序所作的一切事情？<br />是否为一些常用操作建立了命名规范？<br />该子程序是否具有强大的功能内聚性，即做且只做一件事，并且完成得很好？<br />该子程序有松散的耦合性吗？该子程序与其他子程序的关联是简单的、专用的、可见的和灵活的吗？<br />该子程序的长度是否是由它的功能和逻辑自然决定的，而不是由认为制定的编码标准确定的？ |
> | 参数传递问题 | 该子程序的参数列表作为一个整体而言，是否呈现了一致的接口抽象？<br />该子程序的参数是否以一个合理的顺序进行了排列，该排列顺序是否与其他类似子程序的参数顺序一致？<br />对于接口假设是否由文档化记录？<br />该子程序的参数数量少于或等于7个吗？<br />该子程序中是否使用了每个输入参数？<br />该子程序中是否使用了每个输出参数？<br />该子程序中是否避免了把输入参数作为工作变量使用？<br />如果该子程序是一个函数，它是否在所有可能的情况下都返回了一个有效值？                                                                                                                                                                      |
