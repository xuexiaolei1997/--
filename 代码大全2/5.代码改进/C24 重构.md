# 重构

## 24.1 软件演变的类型

软件演变的基本规则是，内部质量应随着代码的演变而提高。

## 24.2 重构简介

为实现软件演化准则，关键策略是重构。

### 重构的理由

代码发生重复

子程序太长

循环太长或嵌套太深

类的内聚力很差

类的接口不能提供一致的抽象层级

参数表有太多参数

在类中进行的修改各自独立

必须并行修改多个类

必须并行修改继承层次结构

必须并行修改case语句

一起使用的相关数据项没有被组织成类

一个子程序使用了另一个类（而非它自己的类）

无脑使用基本数据结构

类的作用不大

子程序链传递流浪数据

中间对象不做任何事情

一个类与另一个类过于亲密

某个子程序的名字太差劲

公共数据成员

一个子类只是用了其父类的一小部分子程序

用注释解释难以理解的代码

全局变量的使用

程序中包含的代码似乎有一天总会用得着

### 不重构的理由

## 24.3 特定的重构

### 数据集重构

用具名常量替换神秘数值，如PI = 3.1415……

用更清晰或更有信息量的名字重命名变量

使表达式内敛

用子程序替代表达式

引入中间变量

将一个多用途的变量转换为多个单用途的变量

局部的用途就用局部变量，而不要用参数

将数据基元转换为类

将一组类型代码转换为类或枚举

将一组类型代码转换为带有子类的类

将数组改为对象

封装集合

用数据类替代传统记录

### 语句级重构

分解布尔表达式

将复杂布尔表达式移入一个良好命名的布尔函数

合并条件语句不同部分的重复片段

使用break或return替代循环控制变量

直到答案后立即返回，而不是在嵌套的if-then-else语句中赋一个返回值

用多态替代条件语句

创建和使用空对象，而不是测试空值

### 子程序级重构

提取子程序/提取方法

内联子程序的代码

将长的子程序转换为类

用简单算法替代复杂算法

增加参数

删除参数

将查询操作与修改操作分开

通过参数化合并类似的子程序

分解行为依赖于传入参数的子程序

传递整个对象而不是特定的字段

传递特定的字段而不是整个对象

封装向下转型

### 类实现重构

将值对象修改为引用对象

将引用对象修改为值对象

用数据初始化替代虚函数

改变成员函数或数据的位置

将特化代码提取到一个子类中

将相似代码合并到超类中

### 类结构重构

将子程序移到另一个类中

将一个类转换为两个

淘汰类

隐藏委托

去掉中间人

用委托代替继承

用继承替代委托

引入外来的子程序

引入扩展类

封装公开的成员变量

删除不可修改的字段的Set子程序

隐藏不打算在类外使用的子程序

封装未使用的子程序

合并实现非常相似的超类和子类

### 系统级重构

为你无法控制的数据创建一个明确的引用源

将单向类关联改为双向类关联

将双向类关联改为单向类关联

提供工厂方法而不是简单构造函数

用异常替代错误代码或相反

## 24.4 安全重构

保存开始时的代码

保持小幅重构

一次一个重构

列出步骤清单

做一个停车场

经常做检查点

利用编译器警告

重新测试

添加测试用例

审查修改

基于重构风险等级来调整方法

### 不宜重构的情况

不要将重构作为编码和修复的幌子

避免重构而不是重写

## 24.5 重构策略

添加子程序时重构

添加类时重构

修复缺陷时重构

瞄准容易出错的模块

瞄准高复杂度的模块

在维护环境中，改进你所接触的部分

在干净的代码和丑陋的代码直接定义一个接口，在通过接口移动代码

> 检查清单：安全重构
>
> | 具体内容                                                           |
> | ------------------------------------------------------------------ |
> | 每次改动都是一个语言改动策略的一部分吗？                           |
> | 重构前是否保存了最开始的代码？                                     |
> | 是否保持每次重构的幅度都很小？                                     |
> | 是否一次只进行一个重构？                                           |
> | 是否列出了在重构过程中打算采取的步骤？                             |
> | 是否做了一个停车场，以便记住重构中途产生的想法？                   |
> | 每次重构后都重新测试了吗？                                         |
> | 若改动很复杂，或者会影响关键任务，是否进行了代码审查？             |
> | 是否考虑过特定重构的风险等级并相应地调整了你的方法？               |
> | 这个修改是否改善而非降低了程序的内部质量？                         |
> | 是否避免了用重构作为编码和修复的皇子，或者作为补充些坏代码的借口？ |
