# 开发人员测试

单元测试

组件测试

集成测试

回归测试

系统测试

## 22.1 开发者测试对软件质量所起的作用

测试是所有软件质量保证项目的重要组成部分，而且在许多情况下，软件质量保证完全依赖于测试。

* 测试的目标与其他开发活动的目标背道而驰。
* 通过测试，永远不能证明软件中已经彻底没有错误。
* 测试本身并不能直接提高软件质量。
* 测试活动要求测试者假定自己会在代码中发现错误。

## 22.2 开发人员测试的推荐方法

* 测试每个相关的需求，以确保需求已经实现。
* 以每个相关的设计重点进行测试，以确保设计已经实现。
* 为这些需求和设计添加详细的测试用例时，先加入一些”基础测试“。
* 列出一个错误检查清单，记录到目前位置在该项目中或在以前项目中所出现过的错误类型。

### 测试是先做还是后做

* 在写代码之前写测试用例，并不比在写代码之后写测试用例花费更多的经理；它知识将写测试用例的活动调换了一下顺序。
* 如果先编写测试用例，就可以更早地检测到缺陷，并且可以更轻松地修正这些错误。
* 先编写测试用例，就会迫使程序员在写代码之前至少会考虑一下需求和设计，这往往会让人们编写出更好的代码。
* 在编写代码之前写测试用例会更早暴露出需求相关的问题，因为根据糟糕的需求编写测试用例会举步维艰。
* 一件理所应当的事是人们会将写好的测试用例保存下来，这种情况下，先做测试还是后做，决定权完全在程序员。

### 开发人员测试的局限性

开发人员测试往往是”干净测试“

开发人员测试往往对测试覆盖率过于乐观

开发人员测试往往会跳过更复杂的测试覆盖类型

## 22.3 一些测试技巧

### 非完整性测试

### 结构化基础测试

### 数据流测试

### 数据状态的组合

### 等价划分

### 错误猜测

### 边界分析

### 复合边界

### 不良的数据类别

典型的不良数据测试用例如下：

* 数据过少（或没有数据）
* 数据过多
* 错误的数据类型（无效数据）
* 错误的数据大小
* 未初始化的数据

### 良好的数据类别

### 使用便于进行手工检查的测试用例

## 22.4 典型错误

### 哪些类包含的错误最多

### 错误分类

大多数错误的范围是相当有限的

许多错误和代码构建无关

大多数代码构建错误都是程序员的人为错误

令人惊讶的是，笔误是问题的常见来源

在对程序员错误的研究中，对设计的误解是个老生常谈的主题

大多数错误修复起来都很容易

度量自己组织的错误相关经验是个好主意

### 由错误构建造成的错误比例

### 测试本身的错误

检查自己的工作

在开发软件时也要规划测试用例

保留测试用例

将单元测试放入测试框架

## 22.5 测试支持工具

### 构建脚手架来测试单个类

### Diff工具

### 测试数据生成器

* 合理设计的随机数据生成器可以生成不同寻常的测试数据组合，以达到意想不到的效果
* 随机数据生成器可以比手动构建测试更彻底地测试程序。
* 随着时间的推移，还可以改进随机生成的测试用例，以便让它们更符合真实的输入范围。
* 在测试过程中，使用模块化设计是有优势的。
* 如果被测试的代码需要修改，还可以重用测试驱动程序。

### 覆盖率测试

### 数据记录器/日志

### 符号调试器

### 系统干扰器

* 内存填充
* 内存抖动
* 选择型内存失效
* 内存访问检查（边界检查）

### 错误数据库

将错误记录在错误数据库中

## 22.6 改进测试

### 测试规划

### 反复测试（回归测试）

### 自动化测试

## 22.7 维护测试记录

通过收集一下数据来对项目进行度量

* 缺陷的管理性描述，比如报告的日期，报告人，标题或描述，软件版本，完成修复的日期
* 问题的完整描述
* 重现问题的步骤
* 建议的问题规避方法
* 相关的缺陷
* 问题的严重程度，例如，致命的、有影响的或无关紧要的
* 缺陷的来源：需求设计、编码或测试
* 代码缺陷的子类别：差一错误、错误赋值、错误的数组索引值、错误的子程序调用等
* 修复时更改的类和子程序
* 受缺陷影响的代码行数
* 检测缺陷所花的时间（小时）
* 修复缺陷所化的时间（小时）

收集完成后，可以通过处理下面的定量信息来判定项目是变得更糟糕还是更健康。

* 每个类中的缺陷数量，是从最差的类到最好的类进行排序，还可以考虑按照类的规模大小进行归一化处理
* 每个子程序中的缺陷数量，从最差的子程序到最好的子程序进行排序，还可以考虑按子程序大小进行归一化处理。
* 查找每个缺陷所花费的平均测试时间
* 每个测试用例发现缺陷的平均数量
* 修复每个缺陷的平均编程时间
* 测试用例覆盖的代码百分比
* 在每个严重程度级别中未解决的缺陷的数量

### 个人测试记录

> 检查清单：测试用例
>
> | 具体内容                                                                                                     |
> | ------------------------------------------------------------------------------------------------------------ |
> | 应用于类或子程序的每个需求都有各自所对应的测试用例吗？                                                       |
> | 应用于类或这程序的设计中每个元素都有各自所对应的测试用例吗？                                                 |
> | 每一行代码都至少用一个测试用例进行测试吗？<br />是否通过计算测试每行代码所需的最小测试数量来对此进行了验证？ |
> | 是否用至少一个测试用例对每条”已定义-已使用“的数据流路径进行了测试？                                        |
> | 是否检查了代码不太可能的数据流模式，例如”已定义-已定义“ ”已定义-已退出“ 和 ”已定义 - 已撤销“ ？        |
> | 在编写测试用例时，是否参考了一个常见错误的列表来检测过去经常见的错误？                                       |
> | 是否测试了所有的简单边界条件：最大值、最小值和差一边界？                                                     |
> | 是否测试了所有的复合边界条件，即多个输入数据的组合可能导致计算得出的变量过小或过大？                         |
> | 测试用例是否检查了错误的数据类型？                                                                           |
> | 是否测试了有代表性的、普遍性的取值？                                                                         |
> | 是否测试了最小正常配置？                                                                                     |
> | 是否测试了最大正常配置？                                                                                     |
> | 是否对旧数据进行了兼容性测试？针对旧的硬件、旧版本的操作系统以及与旧版本的其他软件的接口是否都进行了测试？   |
> | 该测试用例是否易于进行手工检查？                                                                             |
