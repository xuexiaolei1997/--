# 谋定而后动：前期准备

## 3.1 前期准备的重要性

### 前期准备是否适用于现代软件项目

准备工作的首要目标是降低风险：好的项目规划要尽早清楚主要的风险，让项目的主题尽可能顺利地进行。到目前位置，软件开发中最常见的项目风险是糟糕的需求和糟糕的项目规划，因此，准备工作往往集中于改进需求和项目计划上。

为构建做前期准备不是一门精确的科学，用于降低风险的具体方法也必须因不同的项目而异。在不同的项目中，细节可能会有很大的差异。

### 准备工作不充分的根本原因

准备不足的一个常见原因是，被指派从事前期准备活动的开发人员不具备完成任务所需要的专业知识。

有些程序员虽然知道如何执行前期准备活动，但并没有落实到行动上。

程序员不做准备的最后一个原因是，管理人员并不关注那些做足构建前期准备的程序员。

### 构建前要做前期准备，有绝对有力且简明的论据

**诉诸于逻辑**.

有效编程的关键思想之一是重视前期准备工作。

**诉诸于类比**.

构建软件系统与任何其他需要人力和金钱的项目一样。

**诉诸于数据**.

越到后期，修复成本越高

## 3.2 确定要开发什么类型的软件

三种常见软件项目的典型优秀实践

|                          |                                                                                        | **软件类型**                                                             |                                                                                |
| ------------------------ | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------ |
|                          | **商业系统**                                                                     | **任务攸关系统**                                                         | **嵌入式生命攸关系统**                                                   |
| **典型应用**       | 互联网网站<br />内部网网站<br />库存管理<br />游戏<br />信息管理系统<br />薪资管理系统 | 嵌入式软件<br />游戏<br />互联网网站<br />打包软件<br />软件工具<br />网络服务 | 航天软件<br />嵌入式软件<br />医疗设备<br />操作系统<br />打包软件             |
| **生命周期模型**   | 敏捷开发（极限编程、<br />Scrum和时间盒开发等）<br />演进式原型法                      | 阶段式交付<br />演进式交付<br />螺旋式开发                                     | 阶段式交付<br />螺旋式开发<br />演进式交付                                     |
| **计划与管理**     | 增量式项目计划<br />按需测试及质量保证计划<br />非正式变更控制                         | 基本的前期规划<br />基本的测试计划<br />按需质量保证计划<br />正式变更控制     | 充分的前期规划<br />充分的测试规划<br />充分的质量保证计划<br />严格的变更控制 |
| **需求**           | 非正式的需求规格                                                                       | 半正式的需求规格<br />按需需求评审                                             | 正式的需求规格<br />正式的需求审查                                             |
| **设计**           | 设计和编码相结合                                                                       | 架构设计<br />非正式的详细设计<br />按需设计评审                               | 架构设计<br />正式架构审查<br />正式详细设计<br />正式详细设计审查             |
| **构建**           | 结对编码或个体编码<br />非正式代码签入流程或<br />无代码签入流程                       | 结对编码或个体编码<br />非正式代码签入流程<br />按需代码评审                   | 结对编码或个体编码<br />正式代码签入流程<br />正式代码评审                     |
| **测试与质量保证** | 开发自测代码<br />测试先行开发<br />单独测试组无须测试或<br />执行少量测试             | 开发自测代码<br />测试先行开发<br />单独的测试组                               | 开发自测代码<br />测试先行开发<br />独立的测试组<br />独立的质量保证组         |
| **部署**           | 非正式部署流程                                                                         | 正式部署流程                                                                   | 正式部署流程                                                                   |

### 迭代方法对前期的影响

迭代方法倾向于减少前期准备不足所造成的影响，但并不能消除它。

但是迭代法会将平均的缺陷修复成本降低，另一方面，在每次迭代的后期仍然会检测到缺陷，纠正的话需要重新设计、重新编码和重新改测试软件的某些部分，使缺陷纠正的成本远远高于实际所需。

### 迭代式和序列式，如何选择

如果存在下述情况，可能选择序列式：

* 需求相当稳定
* 设计很简单，也很容易理解
* 开发团队熟悉应用程序领域
* 项目几乎没有风险
* 长期的可预测性很重要
* 后期变更需求、设计和代码的成本可能很昂贵

选择迭代法的可能原因如下：

* 需求没有得到充分理解，或者出于其他原因，而认为它们不稳定
* 设计是复杂的、有挑战性的，或者两者兼而有之
* 开发团队不熟悉应用程序领域
* 项目有很多风险
* 长期的可预测性并不重要
* 后期变更需求、设计和代码的成本可能很低

## 3.3 定义问题的先决条件

在开始构建之前，需要满足的第一个先决条件是对系统要解决的问题进行清楚地说明。

问题定义先于详细的需求工作，它是对问题更深入的研究。

## 3.4 需求的先决条件

需求详细描述了软件系统应该做什么，它们是解决方案的第一步。

### 为什么要有正式的需求

明确的需求有助于确保是用户而不是程序员在驾驭系统的功能。

明确的需求也有助于避免争论。

重视需求，有助于在进入开发阶段之后尽可能少去进行系统变更。

### 稳定需求的神话

稳定的需求是软件开发的圣杯。

### 在构建期间处理需求变更

在构建期间，要想充分应对需求变更，可以采用以下方式。

使用本节末尾的需求检查清单来评估需求的质量。

确保每个人都知道需求变更的代价。主要是针对客户。

建立一套变更控制程序。考虑建立一个正式的变更控制委员会，评审提交上来的变更方案。

使用能适应变更的开发方法。某些开发方法能够让人充分响应需求变更。如演进原型法。

放弃这个项目。如果需求特别糟糕或者不稳定。

关注项目的商业案例。需要对商业价值进行评估。

> **检查清单：需求**
>
> 使用需求里氏震级来衡量。
>
> 并不是所有问题都适用于具体的项目。但是在大型项目中，可能需要考虑每一个问题。
>
> | 项                         | 具体问题                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
> | -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
> | 具体的功能需求             | 是否指定了系统的所有输入，包括其来源、精度、值的范围和出现频率？<br />是否指定了系统的所有输出，包括其目标、精度、值的范围、出现频率和格式？<br />是否为web页面和报表等指定了所有输出格式？<br />是否指定了所有外部硬件和软件接口？<br />是否指定了所有外部通信接口，包括握手、错误检查和通信协议？<br />是否指定了用户想要执行的所有任务？<br />是否指定了每个任务中使用的数据和每个任务产生的数据？                                                                                                                                                                                                                                      |
> | 特定的非功能性（质量）需求 | 从用户的角度来看，是否为所有必要的操作指定了预期的响应时间？<br />是否指定了其他时间考虑因素，比如处理时间、数据传输速率和系统吞吐量？<br />是否指定了安全级别？<br />是否指定了可靠性，包括软件故障的后果、需要在故障中得到保护的重要信息以及错误检测和恢复策略？<br />是否指定了最小机器内存和空闲磁盘空间？<br />是否指定了系统的可维护性，包括适应特定功能的更改、操作环境的更改以及与其他软件接口的更改的能力？<br />是否包括了成功和失败的定义？                                                                                                                                                                                     |
> | 需求质量                   | 需求是用用户的语言编写的吗？用户这么认为吗？<br />每个需求都避免了与其他需求的冲突吗？<br />是否详细说明了竞争属性之间的可接受的折中，例如健壮性和正确性的折中？<br />是否避免了在需求中规定设计？<br />需求在详细程度上是一致的吗？是否有需求需要更详细的说明？是否有需求不需要那么详细的说明？<br />需求是否足够清晰，以至于可以移交给一个独立的团队进行构建，且不会产生误解？开发人员这么认为吗？<br />每个条款都与待解决的问题及其解决方案相关吗？能从每个条款上溯到在问题域中对应的根源吗？<br />每个需求都是可测试的吗？是否有可能通过进行独立测试来确定每个需求都被满足了？<br />是否说明了需求的所有可能变更以及每种变更的可能性？ |
> | 需求的完整性               | 对于在开发中无法获得的信息，是否详细描述了信息不完全的区域？<br />需求的完备程度是否可以达到这种程度：如果产品满足所有需求，就说明它是可接受的？<br />对全部需求都感到满意吗？是否已经去掉了那些不可能实现的需求，那些只是为了安抚客户和老板的东西？                                                                                                                                                                                                                                                                                                                                                                                       |

## 3.5 架构的先决条件

软件架构是软件设计的高层部分，是用于支撑更多细节的设计框架。

有些人对架构和高层设计进行区分——架构是指适用于整个系统范围的设计约束，而高层设计是指适用于子系统层次或者多个类的层次上的设计约束（但不是整个系统范围的设计）。

由于架构比需求更接近于构建，所以对架构的讨论比需求更详细一些。

为什么要把架构作为先决条件？一位内架构的质量决定着系统的概念完整性。这反过来有决定着系统的最终质量。一个经过慎重考虑过的架构为从顶层到底层维护系统的架构完整性提供了必备的结构和体系，它为程序员提供了指引——其细节程度要与程序员的技能和手头儿的工作相匹配。

### 典型的架构元素

1.程序的组织

系统架构首先要以概括的形式对系统做一个综述。

架构应当定义系统主要的组件。根据程序的规模不同，各个组件极可能是单独的类，也可能是一个由许多类组成的子系统。每个组件不管是一个单独的类，还是一组协同工作的类和子程序，它们共同实现一种概要功能。

应当明确定义各个组件的责任。每个组件应该负责某个区域的事情，并且对其他组件负责的区域，知道的越少越好。

应当明确定义每个组件的通信原则。架构应当能够描述它能直接使用哪些组件，能间接使用哪些组件，以及不能使用哪些组件。

2.主要的类

架构应当详细定义所使用的主要的类。它应当指出每个主要的类的责任及如何与其他类交互。它应当包含对类的继承体系、状态转换以及对象持久化等的描述。如果系统足够大，那么应当描述如何将这些类组织成一个个子系统。

3.数据设计

架构应当描述所用到的主要文件和数据表的设计。

架构应当详细定义所用数据库的高层组织和内容。

4.业务规则

如果架构依赖于特定的业务规则，就应该详细描述这些规则，并描述这些规则对系统设计的影响。

5.用户界面设计

用户界面常常在需求阶段进行详细说明。

架构应该模块化，以便在用户界面替换时不影响业务规则和程序的输出部分。

6.资源管理

架构应当描述一份管理稀缺资源的计划。稀缺资源包括数据库连接、线程、句柄等。架构应当估算在正常情况和极端情况下的资源使用量。

7.安全性

架构应当描述实现设计层面和代码层面安全性的方法。如果之前尚未建立威胁模型，就应当哎架构阶段建立威胁模型。在制定编码规范的时候应当把安全性牢记在心，包括处理缓冲区的方法、处理不可信数据（用户输出的数据、cookie、）的规则、加密、错误消息的细致程度、保护内存中的秘密数据，以及其他事项。

8.性能

性能目标可以包括资源的使用，这时，性能目标也应当详细定义资源（速度、内存及成本）之间的优先顺序。

架构应当提供估计的数据，并解释为什么架构师相信可以达到性能目标。对于达不到性能的风险，也应当指出。架构中也应当包括各个类或各个对象空间和时间预算。

9.可伸缩性

可伸缩性是系统增长以满足未来需求的能力。架构应当描述系统将如何应对用户数量、服务数量、网络节点数量、数据库记录数量、数据库记录长度、交易量等的增长。

10.互操作性

如果希望系统与其他软件或硬件共享数据或资源，那么架构应该描述如何实现这一点。

11.国际化/本地化

架构可以决定在需要的时候，是在代码中直接嵌入字符串，还是将这些字符串封装到某个类并通过类的接口来使用它或者将这些字符存入资源文件。架构应当说明选用的是哪种方案，并解释原因。

12.输入/输出

输入/输出(I/O)是架构中值得注意的另一个领域。架构应该详细定义读取策略是先查看、后查看还是及时查看。而且，应当描述是在哪一层检测I/O错误：字段、记录、流或文件的层次。

12.错误处理

错误处理是现代计算机科学中最棘手的问题之一。应该在架构层面有一个清楚、一致的错误处理策略。

最好能够上升到架构层面上来建立一个错误处理策略。以下是需要考虑的问题：

* 错误处理是进行纠正，还是仅仅进行检测？纠正可以将程序尝试从错误中恢复过来，检测则可以使程序继续运行，也可以选择退出程序。无论什么情况，都应当通知用户检测到一个错误。
* 错误检测是主动的还是被动的？主动检测包括用户输入校验等，也可以在不能避免的时候，被动响应错误。
* 程序如何传播错误？检测到错误，可以选择丢弃产生错误的数据，也可以进入错误处理状态，或者可以等所有处理完成，再通知用户。
* 错误消息的处理有什么约定？架构应当定义一个一致的处理策略。
* 如何处理异常？架构应该规定代码何时可以抛出异常，在何处捕获异常，如何记录异常，以及如何再文档中描述异常，等等。
* 在程序中，在什么层次上处理错误？可以在发现错误的地方处理，可以将错误传递给专门处理错误的类处理，还可以沿着函数调用链往上传递错误。
* 每个类在验证其输入数据的有效性方面需要负何种责任？是每个类负责验证自己的数据有效性，还是一组类负责验证整个系统的数据有效性？某个层次上的类是否能假设它接收的数据是干净的？
* 你是希望用运行环境中内奸的错误处理机制，还是想建立自己的一套机制？

14.容错性

架构还应当详细定义所期望的容错种类。容错是增强系统可靠性的一组技术，包括检测错误。

15.架构可行性

设计者多半会关注系统的各种能力，如性能是否达标，能够在有限的资源下运转，实现环境是否提供足够支持。架构应当论证系统的技术可行性。

16.过度功能

健壮性是系统在检测到错误后继续运行的能力。通常架构考虑的系统要比需求期望的系统更健壮。

如果组成系统的各个子系统都只能在最低限度上满足健壮性的要求，那么系统整体上是达不到所要求的健壮程度的。

详细定义一种过度工程的方法很重要，因为很多程序员会出于职业自豪感，对自己编写的类做过度工程。通过在架构中明确设立期望目标，就能避免出现某些类异常健壮，而其他类勉强够健壮的情况。

17.是购买还是构建，如何进行决策？

对于成熟组件，可以考虑使用购买方式。

18.关于复用的决策

如何对复用的软件进行加工，使之符合其他架构目标。

19.变更策略

架构应当清晰地描述处理变更的策略。架构应当列出已经考虑的可能会有所增强的功能，并说明最有可能增强的功能同样也是最有可能会去实现的。

如果使用了代码生成器，那么架构应当说明，可预见的变更都不会超出该代码生成器的能力范围。

架构应当指出延迟承诺所用的策略。

20.架构的总体质量

优秀的架构规格书的特点在于，讨论了系统中的类，讨论了每个类后面的隐藏信息，讨论了采纳或排斥所有可能的设计替代方案的根本理由。

架构应当是带有少量特殊情况的精炼且完整的概念体系。

架构的目标应当阐述清楚。以系统可变性为首要目标的设计方案，肯定不同于性能第一的设计方案，即使两个系统的功能一样。

架构应当描述所有主要的决策的动机，并且需要去除主观化。

架构在很大程度上与机器和编程语言无关。

架构应该处于对系统欠描述和过度描述之间的那条分界线上。

架构应当明确地指出有风险的区域。应当解释为什么这个区域是有风险的，并说明采取了哪些步骤使得风险最小化。

架构应该包含多个视角。

> 检查清单：架构
>
> 优秀的架构应该关注这些问题
>
> | 项                       | 具体问题                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
> | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | **针对各架构主题** | 项目的整体组织是否清晰，包括良好的架构概述机器理由？<br />主要构建是否定义良好，包括它们职责范围以及它们与其他构建的接口？<br />在需求中列出的所有功能都被合理覆盖了吗？<br />最关键的类是否有描述和论证？<br />数据设计是否有描述和论证？<br />是否说明了数据库的组织和内容？<br />是否确定了所有关键业务规则及其对系统的影响？<br />是否描述了用户界面设计的策略？<br />用户界面是模块化的，因此它的更改不会影响程序的其余部分吗？<br />是否描述并论证了处理I/O的策略？<br />是否估算了稀缺资源（如线程、数据库连接、句柄和网络带宽等）的使用量，是否描述并论证了资源管理的策略？<br />是否描述了架构的安全需求？<br />架构是否为每个类、每个子系统或每个功能域提出时间和空间预算？<br />架构是否描述了如何实现可伸缩性？<br />架构是否关注了互操作性？<br />是某描述了国际化和本地化的策略？<br />是否提供了一套一致性的错误处理策略？<br />是否提供了容错的方法（如果需要的话）？<br />是否证实了系统各部分的技术可行性？<br />是否详细描述了过度工程的方法？<br />是否包含了必要的购买还是构建的决策？<br />架构是某描述了如何加工被复用的代码，使之符合其他架构目标？<br />架构的设计是否能够适应极有可能出现从变更？ |
> | **架构的总体质量** | 架构是否解决了全部需求？<br />有没有哪个部分是过度架构或欠架构？是否明确提出了这方面的具体目标？<br />整个架构是否在概念上协调一致？<br />顶层设计是否独立于用于实现它的机器和语言？<br />是否提供了所有主要决策的动机？<br />作为一个将要实现系统的程序员，是否对架构感到满意？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

## 3.6 前期准备所花费的时间
